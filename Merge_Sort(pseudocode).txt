MergeSort(A, l, h){
  if(l<h){
    mid = floor((l+h)/2)
    MergesSort(A, l, mid)
    MergeSort(A, mid+1, h)
    Merge(A, l, mid, h)
  }
}

Merge(A, l, mid, h){
  sz1 = (mid-l)+1
  sz2 = (h-mid)
  a[sz1]
  b[sz2]
  k=l
  for(i=0; i<sz1; i=i+1){
    a[i]=A[k]
    k = k+1
  }
  for(j=mid+1; j<=h; j=j+1){
    b[j-mid-1]=A[j];
  }
  i=0
  j=0
  k=l
  while(i<sz1 and j<sz2){
    if(a[i]<b[j]){
      A[k] = a[i]
      i = i+1
    }
    else{
      A[k] = b[j]
      j = j+1
    }
    k = k+1
  }
  while(i<sz1){
    A[k] = a[i]
    i = i+1
    k = k+1
  }
  while(j<sz2){
    A[k] = b[j]
    k = k+1
  }
}







###################### Complexity ###########################

T(n) = 1 + T(n/2) + T(n/2) + (4+2+4n+3+6n)
     = 1 + T(n/2) + T(n/2) + 10n + 9
     = 2T(n/2) + 10n + 10
     = 2T(n/2) + 10n [10 is a constant]
     = 2T(n/2) + cn [10=c] ---> {1}
     = 2(2T(n/4)+cn/2)+cn
     = 4T(n/4) + 2cn       ---> {2}
     = 4(2T(n/8) + cn/4) + 2cn
     = 8T(n/8) + 3cn       ---> {3}
          .
          :
          :
          .
     = 2^k T(n/(2^k)) + kcn ---> {k}
     At a certain point this term- T(n/(2^k)) will be equal to 1. So at Kth term the eqn. will be -
     2^k + kcn
     And n/(2^k) = 1 => n = 2^k => log(n) = log(2^k) => k = log(n)
     So, T(n) = 2^k + kcn
              = 2^(log(n)) + cnlog(n)
              = n + cnlog(n)
 
 Therefore,
      T(n) = n + cnlog(n) <=O(g(n))
           = n + c0nlog(n) <=c1(nlog(n))
           
        Time Complexity: O(nlog(n))
        Space Complexity: O(n)
      
